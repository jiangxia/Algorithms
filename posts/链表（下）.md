本文总结了几个写链表代码技巧。

# 理解指针或引用的含义

指针或引用的含义，就是存储所指对象的内存地址。

通过指针或引用，就能找到这个变量。

示例：
p—>next = q; 表示p节点的后继指针存储了q节点的内存地址。
p—>next = p—>next—>next; 表示p节点的后继指针存储了p节点的下下个节点的内存地址。

<br/>

# 警惕指针丢失和内存泄漏

我们希望在结点a和相邻的结点b之间插入结点x，假设当前指针p指向结点a。如果我们将代码实现变成下面这个样子，就会发生指针丢失和内存泄露。

<br/>
<img src='https://github.com/jiangxia/Algorithms/raw/master/images/11.jpg' width='800'>
<br/>

```
p->next = x;  // 将p的next指针指向x结点；
x->next = p->next;  // 将x的结点的next指针指向b结点；
```

p->next指针在完成第一步操作之后，已经不再指向结点b了，而是指向结点x。第2行代码相当于将x赋值给x->next，自己指向自己。因此，整个链表也就断成了两半，从结点b往后的所有结点都无法访问到了。

所以，我们插入结点时，一定要注意操作的顺序，要先将结点x的next指针指向结点b，再把结点a的next指针指向结点x，这样才不会丢失指针，导致内存泄漏。所以，对于刚刚的插入代码，我们只需要把第1行和第2行代码的顺序颠倒一下就可以了。

同理，删除链表结点时，也一定要记得手动释放内存空间，否则，也会出现内存泄漏的问题。当然，对于像Java这种虚拟机自动管理内存的编程语言来说，就不需要考虑这么多了。

<br/>

# 利用哨兵简化实现难度

## 什么是哨兵

链表中的“哨兵”节点是解决边界问题的，不参与业务逻辑。如果我们引入“哨兵”节点，则不管链表是否为空，head指针都会指向这个“哨兵”节点。我们把这种有“哨兵”节点的链表称为带头链表，相反，没有“哨兵”节点的链表就称为不带头链表。

## 未引入“哨兵”的情况

如果在p节点后插入一个节点，只需2行代码即可搞定：

```
new_node—>next = p—>next;
p—>next = new_node;
```

但，若向空链表中插入一个节点，则代码如下：

```
if(head == null){
  head = new_node;
}
```

如果要删除节点p的后继节点，只需1行代码即可搞定：

```
p—>next = p—>next—>next;
```

但，若是删除链表的最有一个节点（链表中只剩下这个节点），则代码如下：

```
if(head—>next == null){
  head = null;
}
```

从上面的情况可以看出，针对链表的插入、删除操作，需要对插入第一个节点和删除最后一个节点的情况进行特殊处理。这样代码就会显得很繁琐，所以引入“哨兵”节点来解决这个问题。

## 引入“哨兵”的情况

“哨兵”节点不存储数据，无论链表是否为空，head指针都会指向它，作为链表的头结点始终存在。这样，插入第一个节点和插入其他节点，删除最后一个节点和删除其他节点都可以统一为相同的代码实现逻辑了。


<br/>
<img src='https://github.com/jiangxia/Algorithms/raw/master/images/12.jpg' width='600'>
<br/>


## 应用场景

哨兵最大的作用就是简化边界条件的处理。

<br/>

# 四、重点留意边界条件处理

经常用来检查链表是否正确的边界4个边界条件：

1. 如果链表为空时，代码是否能正常工作？
2. 如果链表只包含一个节点时，代码是否能正常工作？
3. 如果链表只包含两个节点时，代码是否能正常工作？
4. 代码逻辑在处理头尾节点时是否能正常工作？

<br/>

# 五、举例画图，辅助思考

核心思想：释放脑容量，留更多的给逻辑思考，这样就会感觉到思路清晰很多。

比如往单链表中插入一个数据这样一个操作，我一般都是把各种情况都举一个例子，画出插入前和插入后的链表变化，如图所示：

<br/>
<img src='https://github.com/jiangxia/Algorithms/raw/master/images/13.jpg' width='800'>
<br/>

# 六、多写多练，没有捷径

5个常见的链表操作：

1. 单链表反转
2. 链表中环的检测
3. 两个有序链表合并
4. 删除链表倒数第n个节点
5. 求链表的中间节点 