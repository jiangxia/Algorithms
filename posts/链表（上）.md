# 什么是链表？

和数组一样，链表也是一种线性表。

从内存结构来看，链表的内存结构是不连续的内存空间，是将一组零散的内存块串联起来，从而进行数据存储的数据结构。

<br/>

# 单链表

为了将所有的结点串起来，链表的每个节点包含一个指针，即后继指针next。

<br/>
<img src='https://github.com/jiangxia/Algorithms/raw/master/images/6.jpg' width='600'>
<br/>

单链表有两个特殊的节点，即首节点和尾节点。为什么特殊？用首节点地址表示整条链表，尾节点的后继指针指向空地址null。

性能特点：插入和删除节点的时间复杂度为O(1)，查找的时间复杂度为O(n)。

<br/>
<img src='https://github.com/jiangxia/Algorithms/raw/master/images/7.jpg' width='800'>
<br/>

# 循环链表

除了尾节点的后继指针指向首节点的地址外，均与单链表一致。

<br/>
<img src='https://github.com/jiangxia/Algorithms/raw/master/images/7.jpg' width='600'>
<br/>

适用于处理存储有循环特点的数据，比如约瑟夫问题。

<br/>

# 双向链表

节点除了存储数据外，还有两个指针分别指向前一个节点地址（前驱指针prev）和下一个节点地址（后继指针next）。

首节点的前驱指针prev和尾节点的后继指针均指向空地址。

<br/>
<img src='https://github.com/jiangxia/Algorithms/raw/master/images/9.jpg' width='800'>
<br/>

## 性能特点

和单链表相比，存储相同的数据，需要消耗更多的存储空间。

双向链表可以支持O(1)时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。

以删除操作为例，删除操作分为2种情况：给定数据值删除对应节点和给定节点地址删除节点。

对于前一种情况，单链表和双向链表都需要从头到尾进行遍历从而找到对应节点进行删除，时间复杂度为O(n)。

对于第二种情况，要进行删除操作必须找到前驱节点，单链表需要从头到尾进行遍历直到p->next = q，时间复杂度为O(n)，而双向链表可以直接找到前驱节点，时间复杂度为O(1)。

除了插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置p，每次查询时，根据要查找的值与p的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。

<br/>

# 双向循环链表

首节点的前驱指针指向尾节点，尾节点的后继指针指向首节点。

<br/>
<img src='https://github.com/jiangxia/Algorithms/raw/master/images/10.jpg' width='800'>
<br/>

# 选择数组还是链表？

## 插入、删除和随机访问的时间复杂度
数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)。
链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂端是O(n)。

## 数组缺点

若申请内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M。

大小固定，若存储空间不足，需进行扩容，一旦扩容就要进行数据复制，而这时非常费时的。

## 链表缺点

内存空间消耗更大，因为需要额外的空间存储指针信息。

对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片，如果是Java语言，还可能会造成频繁的GC（自动垃圾回收器）操作。
