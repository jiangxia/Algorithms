# 前言

数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。

所以，执行效率是算法一个非常重要的考量指标。

<br/>

# 为什么需要复杂度分析？

其实，除了复杂度分析，我们还有其他途径分析代码执行效率，比如事后统计法。

但事后统计是有局限性的：

- 不同的环境测试结果差异大
- 数据本身规模会影响结果（如数据规模小，结果无法真实反应出算法的性能问题）

所以，我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。这就是我们今天要讲的时间、空间复杂度分析方法。

<br/>

# 大O复杂度表示法

## 来源

算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。

## 特点

大O时间复杂度实际上并不具体表示代码真正的执行时间，而是表示**代码执行时间随数据规模增长的变化趋势**，所以，也叫作渐进时间复杂度，简称**时间复杂度**。

当一段代码的执行时间为T(n) = O(2n²+2n+3)，这就是大O时间复杂度表示法。

当n很大时，你可以把它想象成10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，上面的公式就可以简化为T(n) = O(n²)。

<br/>

# 时间复杂度分析

这里有三个比较实用的方法：

- 只关注循环执行次数最多的一段代码
- 加法法则：总复杂度等于量级最大的那段代码的复杂度
- 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

简单地说，就是：

- 单段代码看高频：比如循环。
- 多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。
- 嵌套代码求乘积：比如递归、多重循环等

<br/>

# 常见的时间复杂度

虽然代码千差万别，但是常见的复杂度量级并不多。我稍微总结了一下，这些复杂度量级几乎涵盖了你今后可以接触的所有代码的复杂度量级。

<br/>
<img src='https://github.com/jiangxia/Algorithms/raw/master/images/2.jpg' width='800'>
<br/>

复杂度量级虽多，却可以粗略地分为两类，多项式量级和非多项式量级。

## 非多项式阶

非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差，所以不打算展开讲。包括O(2^n)（指数阶）、O(n!)（阶乘阶）

## 多项式阶

多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，
O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）

### O(1)

一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)

### O(logn)、O(nlogn)

对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。我通过一个例子来说明一下。

```js
i=1;
while (i <= n)  {
  i = i * 2;
}
```

这段代码的时间复杂度就是O(log₂n)。

实际上，不管是以2为底、以3为底，还是以10为底，我们可以把所有对数阶的时间复杂度都记为O(logn)。

如果一段代码的时间复杂度是O(logn)，我们循环执行n遍，时间复杂度就是O(nlogn)了。而且，O(nlogn)也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是O(nlogn)。

### O(m+n)、O(m*n)

我们再来讲一种跟前面都不一样的时间复杂度，代码的复杂度由两个数据的规模来决定。老规矩，先看代码！

```java
int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```

从代码中可以看出，m和n是表示两个数据规模。我们无法事先评估m和n谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是O(m+n)。

<br/>

# 空间复杂度分析

**时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系**。

类比一下，**空间复杂度全称就是渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系**。

拿具体的例子说明一下。

```java
void print(int n) {
  int i = 0;
  int[] a = new int[n];
  for (i; i <n; ++i) {
    a[i] = i * i;
  }

  for (i = n-1; i >= 0; --i) {
    print out a[i]
  }
}
```

跟时间复杂度分析一样，我们可以看到，第2行代码中，我们申请了一个空间存储变量i，但是它是常量阶的，跟数据规模n没有关系，所以我们可以忽略。第3行申请了一个大小为n的int类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是O(n)。

我们常见的空间复杂度就是O(1)、O(n)、O(n²)，像O(logn)、O(nlogn)这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。所以，对于空间复杂度，掌握刚我说的这些内容已经足够了。

<br/>

# 小结

复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n²)。


<br/>
<img src='https://github.com/jiangxia/Algorithms/raw/master/images/3.jpg' width='600'>
<br/>

复杂度分析关键在于多练，所谓孰能生巧。 